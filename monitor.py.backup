#!/usr/bin/env python3
"""
Module de surveillance du signal FM avec RTL-SDR - Calcul RMS direct
Basé sur l'approche fonctionnelle avec lecture directe du stdout
"""
import subprocess
import threading
import queue
import json
import logging
import time
import os
import numpy as np
from datetime import datetime
from email_alert import EmailAlert
from database import FMDatabase

logger = logging.getLogger(__name__)

class FMMonitor:
    def __init__(self, config_path='config.json'):
        """Initialise le moniteur FM"""
        with open(config_path, 'r') as f:
            self.config = json.load(f)
        
        self.rtl_config = self.config['rtl_sdr']
        self.audio_config = self.config['audio']
        
        # Queue pour le streaming MP3 (augmentée à 500)
        self.stream_queue = queue.Queue(maxsize=500)
        
        # Processus
        self.master_process = None
        self.sox_process = None
        self.monitor_thread = None
        self.running = False
        
        # État de la surveillance
        self.signal_ok = True
        self.silence_start_time = None
        self.alert_sent = False
        
        # Système d'alertes
        self.email_alert = EmailAlert(config_path)
        
        # Statistiques avec niveau RMS précis
        self.stats = {
            'start_time': None,
            'uptime': 0,
            'alerts_sent': 0,
            'last_alert': None,
            'current_level': -100.0,  # dBFS précis
            'ps': 'RECHERCHE...',  # Program Service (nom station RDS)
            'rt': '',  # RadioText (infos RDS)
            'status': 'Arrêté'
        }
        
        # Buffer pour accumuler le RadioText
        self.rt_buffer = ''
        self.rt_ab_flag = None  # Flag A/B pour détecter le début d'un nouveau message
        
        # Lock pour thread-safety
        self.stats_lock = threading.Lock()
        
        # Base de données
        self.db = FMDatabase()
        self.last_db_save = time.time()
    
    def start(self):
        """Démarre la capture et la surveillance FM"""
        if self.running:
            logger.warning("Le moniteur est déjà en cours d'exécution")
            return
        
        logger.info(f"Démarrage de la surveillance FM sur {self.rtl_config['frequency']}")
        self.running = True
        self.stats['start_time'] = datetime.now()
        self.stats['status'] = 'En cours'
        
        # Nettoyer les processus existants
        os.system("pkill -9 rtl_fm 2>/dev/null")
        os.system("pkill -9 sox 2>/dev/null")
        time.sleep(0.5)
        
        try:
            # Démarrer le processus maître
            self.master_thread = threading.Thread(target=self._master_monitor, daemon=True)
            self.master_thread.start()
            
            # Démarrer le streaming MP3
            self.stream_thread = threading.Thread(target=self._stream_monitor, daemon=True)
            self.stream_thread.start()
            
            # Démarrer le lecteur RDS
            self.rds_thread = threading.Thread(target=self._rds_reader, daemon=True)
            self.rds_thread.start()
            
            # Thread de surveillance du niveau
            self.monitor_thread = threading.Thread(target=self._monitor_signal, daemon=True)
            self.monitor_thread.start()
            
            # Démarrer le watchdog
            self.watchdog_thread = threading.Thread(target=self._watchdog, daemon=True)
            self.watchdog_thread.start()
            
            logger.info("Surveillance FM démarrée avec succès (calcul RMS direct + watchdog)")
        except Exception as e:
            logger.error(f"Erreur lors du démarrage: {e}")
            self.stop()
            raise
    
    def _watchdog(self):
        """Thread de surveillance qui relance rtl_fm si crash"""
        logger.info("Watchdog démarré")
        
        while self.running:
            try:
                time.sleep(10)  # Vérifier toutes les 10 secondes
                
                if not self.running:
                    break
                
                # Vérifier si le processus master est mort
                if self.master_process and self.master_process.poll() is not None:
                    logger.error("rtl_fm a planté ! Relance automatique...")
                    
                    # Nettoyer les processus zombies
                    os.system("pkill -9 rtl_fm 2>/dev/null")
                    os.system("pkill -9 sox 2>/dev/null")
                    os.system("pkill -9 redsea 2>/dev/null")
                    time.sleep(2)
                    
                    # Relancer le processus maître
                    self.master_thread = threading.Thread(target=self._master_monitor, daemon=True)
                    self.master_thread.start()
                    
                    logger.info("rtl_fm relancé automatiquement")
            
            except Exception as e:
                logger.error(f"Erreur watchdog: {e}")
    
    def _master_monitor(self):
        """
        Processus maître : UN SEUL rtl_fm à 171k avec tee pour tout
        - Branche 1 : redsea pour RDS
        - Branche 2 : sox pour MP3
        - Stdout : Python pour calcul RMS
        """
        # IMPORTANT: 171k pour le RDS (obligatoire)
        sample_rate = '171000'
        
        # Commande avec tee multiples
        # rtl_fm 171k | tee >(redsea) | tee >(sox) | (Python pour RMS)
        cmd = (
            f"stdbuf -o0 rtl_fm "
            f"-f {self.rtl_config['frequency']} "
            f"-M wbfm -s 171k -r 171k "
            f"-g {self.rtl_config['gain']} "
            f"-p {self.rtl_config['ppm_error']} "
            f"-A fast | "
            f"tee >(stdbuf -oL redsea -p > /tmp/rds_output.json) | "
            f"tee >(sox -t raw -r {sample_rate} -e signed -b 16 -c 1 - "
            f"-t mp3 -r {self.audio_config['output_rate']} -C 128 - "
            f"> /tmp/fm_stream.mp3) | cat"
        )
        
        logger.info("Lancement du processus maître rtl_fm 171k avec tee (RDS+Audio+RMS)")
        
        # Nettoyer l'ancien fichier RDS
        if os.path.exists('/tmp/rds_output.json'):
            os.remove('/tmp/rds_output.json')
        
        try:
            self.master_process = subprocess.Popen(
                cmd,
                shell=True,
                executable='/bin/bash',
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                bufsize=0
            )
            
            # Lire stdout pour calcul RMS direct
            chunk_size = 4096  # 2048 échantillons
            
            while self.running and self.master_process.poll() is None:
                chunk = self.master_process.stdout.read(chunk_size)
                if not chunk:
                    break
                
                try:
                    # Convertir en int16
                    samples = np.frombuffer(chunk, dtype=np.int16)
                    
                    if len(samples) < 10:
                        continue
                    
                    # Calculer RMS direct
                    rms = np.sqrt(np.mean(np.square(samples.astype(np.float32))))
                    
                    # Convertir en dBFS
                    if rms > 0:
                        db = 20 * np.log10(rms / 32768.0)
                    else:
                        db = -100.0
                    
                    # Mettre à jour les stats (convertir en float Python)
                    with self.stats_lock:
                        self.stats['current_level'] = float(db)
                    
                    # Sauvegarder en BDD toutes les 5 secondes
                    if time.time() - self.last_db_save >= 5:
                        self.db.save_audio_level(float(db), self.signal_ok)
                        self.last_db_save = time.time()
                
                except Exception as e:
                    logger.error(f"Erreur calcul RMS: {e}")
        
        except Exception as e:
            logger.error(f"Erreur processus maître: {e}")
        finally:
            if self.master_process:
                self.master_process.kill()
    
    def _stream_monitor(self):
        """Lit /tmp/fm_stream.mp3 et le met dans la queue"""
        logger.info("Démarrage du monitoring du stream MP3")
        
        while not os.path.exists('/tmp/fm_stream.mp3'):
            time.sleep(0.1)
        
        try:
            with open('/tmp/fm_stream.mp3', 'rb') as f:
                while self.running:
                    chunk = f.read(8192)
                    if chunk:
                        try:
                            self.stream_queue.put(chunk, timeout=0.1)
                        except queue.Full:
                            try:
                                self.stream_queue.get_nowait()
                            except queue.Empty:
                                pass
                    else:
                        time.sleep(0.05)
        except Exception as e:
            logger.error(f"Erreur stream MP3: {e}")
    
    def _rds_reader(self):
        """Lit les données RDS depuis /tmp/rds_output.json"""
        logger.info("Démarrage lecteur RDS")
        
        while not os.path.exists('/tmp/rds_output.json'):
            time.sleep(0.5)
        
        try:
            proc = subprocess.Popen(
                ['tail', '-f', '/tmp/rds_output.json'],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                bufsize=1
            )
            
            for line in proc.stdout:
                if not self.running:
                    break
                
                try:
                    data = json.loads(line.strip())
                    
                    with self.stats_lock:
                        # Program Service (nom de la station)
                        if 'ps' in data:
                            self.stats['ps'] = data['ps']
                            logger.debug(f"RDS PS: {data['ps']}")
                        
                        # RadioText avec accumulation progressive des segments
                        if 'partial_radiotext' in data:
                            rt_segment = data['partial_radiotext'].strip()
                            rt_ab = data.get('rt_ab', 'A')
                            
                            # Si le flag A/B change, c'est un nouveau message - réinitialiser
                            if self.rt_ab_flag is not None and self.rt_ab_flag != rt_ab:
                                logger.info(f"RDS RT complet: {self.rt_buffer}")
                                self.stats['rt'] = self.rt_buffer.strip()
                                self.rt_buffer = ''
                            
                            self.rt_ab_flag = rt_ab
                            
                            # Accumuler progressivement si le segment est plus long
                            if rt_segment:
                                # Si le nouveau segment est plus long, on le garde
                                if len(rt_segment) > len(self.rt_buffer):
                                    self.rt_buffer = rt_segment
                                    self.stats['rt'] = rt_segment
                                    logger.info(f"RDS RT accumulé: {rt_segment}")
                
                except json.JSONDecodeError:
                    continue
                except Exception as e:
                    logger.error(f"Erreur lecture RDS: {e}")
        
        except Exception as e:
            logger.error(f"Erreur processus RDS: {e}")
    
    def _monitor_signal(self):
        """Surveille le niveau du signal et envoie des alertes"""
        logger.info("Thread de surveillance démarré")
        
        while self.running:
            try:
                with self.stats_lock:
                    current_level = self.stats['current_level']
                
                threshold = self.audio_config['silence_threshold']
                
                logger.info(f"CHECK: level={current_level:.2f} dB | threshold={threshold} dB | signal_ok={self.signal_ok}")
                
                if current_level < threshold:
                    if self.signal_ok:
                        self.signal_ok = False
                        self.silence_start_time = time.time()
                        logger.warning(f"Signal faible détecté: {current_level:.2f} dB")
                    else:
                        silence_duration = time.time() - self.silence_start_time
                        
                        if silence_duration >= self.audio_config['silence_duration'] and not self.alert_sent:
                            logger.error(f"Signal perdu depuis {silence_duration:.0f}s")
                            
                            success = self.email_alert.send_alert(
                                subject=f"[ALERTE] Signal FM perdu - {self.config['station']['name']}",
                                level=current_level
                            )
                            
                            if success:
                                self.alert_sent = True
                                with self.stats_lock:
                                    self.stats['alerts_sent'] += 1
                                    self.stats['last_alert'] = datetime.now().isoformat()
                                
                                # Enregistrer l'alerte en BDD
                                self.db.save_alert(
                                    alert_type='signal_lost',
                                    level_db=current_level,
                                    duration_seconds=int(silence_duration),
                                    message=f"Signal perdu - {current_level:.2f} dB",
                                    email_sent=True
                                )
                else:
                    if not self.signal_ok:
                        logger.info(f"Signal rétabli: {current_level:.2f} dB")
                    self.signal_ok = True
                    self.silence_start_time = None
                    self.alert_sent = False
                
                
                # Mettre à jour uptime
                if self.stats['start_time']:
                    uptime = (datetime.now() - self.stats['start_time']).total_seconds()
                    with self.stats_lock:
                        self.stats['uptime'] = int(uptime)
                
                time.sleep(1)
            
            except Exception as e:
                logger.error(f"Erreur surveillance: {e}")
                time.sleep(1)
    
    def get_audio_chunk(self):
        """Récupère un chunk audio pour le streaming"""
        try:
            return self.stream_queue.get(timeout=0.1)
        except queue.Empty:
            return None
    
    def get_stats(self):
        """Récupère les statistiques"""
        with self.stats_lock:
            stats = self.stats.copy()
        
        stats['signal_ok'] = self.signal_ok
        stats['frequency'] = self.rtl_config['frequency']
        
        if stats['start_time']:
            stats['start_time'] = stats['start_time'].strftime('%d/%m/%Y %H:%M:%S')
        
        return stats
    
    def stop(self):
        """Arrête le moniteur"""
        logger.info("Arrêt du moniteur FM")
        self.running = False
        
        if self.master_process:
            self.master_process.kill()
        
        os.system("pkill -9 rtl_fm 2>/dev/null")
        os.system("pkill -9 sox 2>/dev/null")
        os.system("pkill -9 redsea 2>/dev/null")
        
        self.stats['status'] = 'Arrêté'
